<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Tangram</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/caiuss/1.0.2/caiuss.min.css"
      type="text/css"
      media="screen"
      charset="utf-8"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/sweetalert/1.1.3/sweetalert.css"
      type="text/css"
      media="screen"
      charset="utf-8"
    />
    <!-- <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8"> -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/octicons/3.5.0/octicons.min.css"
      type="text/css"
      media="screen"
      charset="utf-8"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/2.0.2/svg.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sweetalert/1.1.3/sweetalert.min.js"></script>
    <!-- <script src="js/svg.select.min.js"></script>
        <script src="js/svg.draggy.js"></script>
        <script src="js/css.rotate.js"></script>
        <script src="js/crossy.js"></script>
        <script src="js/index.js"></script> -->

    <style>
      .graph {
        z-index: 9;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }

      .title {
        position: fixed;
        z-index: 10;
        pointer-events: none;
        color: #2d8bc9;
        left: 55px;
        border: 5px solid;
        padding-bottom: 3px;
        top: -5px;
        padding-right: 20px;
      }

      .title h1 {
        display: inline;
        padding: 0px;
        padding-left: 20px;
      }

      polygon {
        -webkit-transition: all 0.5s ease;
        -moz-transition: all 0.5s ease;
        -ms-transition: all 0.5s ease;
        -o-transition: all 0.5s ease;
        transition: all 0.5s ease;
        cursor: pointer;
      }

      ul {
        list-style: none;
        padding: 0;
      }
      .sidebar {
        background: #3498db;
        position: fixed;
        z-index: 999;
      }

      .sidebar span.octicon {
        font-size: 40px;
        color: #fff;
        padding: 14px;
      }

      .sidebar-item {
        text-align: center;
        border-bottom: 5px solid #2d8bc9;
        cursor: pointer;
      }

      .sidebar-item:hover {
        background: #2d8bc9;
      }

      .made-with-heart a,
      .made-with-heart a:hover {
        color: #2d8bc9;
      }

      .made-with-heart a:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
   
    <div class="graph"></div>
    <div class="sidebar">
      <div class="sidebar-item" onclick="showTutorial()">
        <span class="octicon octicon-question"></span>
      </div>
    </div>
  </body>
  <!-- <script src="js/svg.select.min.js"></script>
        <script src="js/svg.draggy.js"></script>
        <script src="js/css.rotate.js"></script>
        <script src="js/crossy.js"></script>
        <script src="js/index.js"></script> -->
  <script>
    /*! svg.select.js - v1.0.5 - 2015-06-26
     * https://github.com/Fuzzyma/svg.select.js
     * Copyright (c) 2015 Ulrich-Matthias SchÃ¤fer; Licensed MIT */
    (function (a) {
      function b(a) {
        (this.el = a),
          (this.parent = a.parent(SVG.Nested) || a.parent(SVG.Doc)),
          a.remember("_selectHandler", this),
          (this.pointSelection = { isSelected: !1 }),
          (this.rectSelection = { isSelected: !1 });
      }
      (b.prototype.init = function (b, c) {
        var d = this.el.bbox();
        this.options = {};
        for (var e in this.el.select.defaults)
          (this.options[e] = this.el.select.defaults[e]),
            c[e] !== a && (this.options[e] = c[e]);
        (this.nested = (this.nested || this.parent.nested())
          .size(d.width || 1, d.height || 1)
          .transform(this.el.ctm())
          .move(d.x, d.y)),
          this.options.deepSelect &&
          -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type)
            ? this.selectPoints(b)
            : this.selectRect(b),
          this.observe(),
          this.cleanup();
      }),
        (b.prototype.selectPoints = function (a) {
          return (
            (this.pointSelection.isSelected = a),
            this.pointSelection.set
              ? this
              : ((this.pointSelection.set = this.parent.set()),
                this.drawCircles(),
                this)
          );
        }),
        (b.prototype.getPointArray = function () {
          var a = this.el.bbox();
          return this.el
            .array()
            .valueOf()
            .map(function (b) {
              return [b[0] - a.x, b[1] - a.y];
            });
        }),
        (b.prototype.drawCircles = function () {
          for (
            var a = this, b = this.getPointArray(), c = 0, d = b.length;
            d > c;
            ++c
          )
            this.pointSelection.set.add(
              this.nested
                .circle(this.options.radius)
                .center(b[c][0], b[c][1])
                .addClass(this.options.classPoints)
                .addClass(this.options.classPoints + "_point")
                .mousedown(
                  (function (b) {
                    return function (c) {
                      (c = c || window.event),
                        c.preventDefault
                          ? c.preventDefault()
                          : (c.returnValue = !1),
                        a.el.fire("point", {
                          x: c.pageX,
                          y: c.pageY,
                          i: b,
                          event: c,
                        });
                    };
                  })(c)
                )
            );
        }),
        (b.prototype.updatePointSelection = function () {
          var a = this.getPointArray();
          this.pointSelection.set.each(function (b) {
            (this.cx() !== a[b][0] || this.cy() !== a[b][1]) &&
              this.center(a[b][0], a[b][1]);
          });
        }),
        (b.prototype.updateRectSelection = function () {
          var a = this.el.bbox();
          this.rectSelection.set
            .get(0)
            .attr({ width: a.width, height: a.height }),
            this.options.points &&
              (this.rectSelection.set.get(2).center(a.width, 0),
              this.rectSelection.set.get(3).center(a.width, a.height),
              this.rectSelection.set.get(4).center(0, a.height),
              this.rectSelection.set.get(5).center(a.width / 2, 0),
              this.rectSelection.set.get(6).center(a.width, a.height / 2),
              this.rectSelection.set.get(7).center(a.width / 2, a.height),
              this.rectSelection.set.get(8).center(0, a.height / 2)),
            this.options.rotationPoint &&
              this.rectSelection.set.get(9).center(a.width / 2, 20);
        }),
        (b.prototype.selectRect = function (a) {
          function b(a) {
            return function (b) {
              (b = b || window.event),
                b.preventDefault ? b.preventDefault() : (b.returnValue = !1),
                c.el.fire(a, { x: b.pageX, y: b.pageY, event: b });
            };
          }
          var c = this,
            d = this.el.bbox();
          (this.rectSelection.isSelected = a),
            (this.rectSelection.set =
              this.rectSelection.set || this.parent.set()),
            this.rectSelection.set.get(0) ||
              this.rectSelection.set.add(
                this.nested
                  .rect(d.width, d.height)
                  .addClass(this.options.classRect)
              ),
            this.options.points &&
              !this.rectSelection.set.get(1) &&
              (this.rectSelection.set.add(
                this.nested
                  .circle(this.options.radius)
                  .center(0, 0)
                  .attr("class", this.options.classPoints + "_lt")
                  .mousedown(b("lt"))
              ),
              this.rectSelection.set.add(
                this.nested
                  .circle(this.options.radius)
                  .center(d.width, 0)
                  .attr("class", this.options.classPoints + "_rt")
                  .mousedown(b("rt"))
              ),
              this.rectSelection.set.add(
                this.nested
                  .circle(this.options.radius)
                  .center(d.width, d.height)
                  .attr("class", this.options.classPoints + "_rb")
                  .mousedown(b("rb"))
              ),
              this.rectSelection.set.add(
                this.nested
                  .circle(this.options.radius)
                  .center(0, d.height)
                  .attr("class", this.options.classPoints + "_lb")
                  .mousedown(b("lb"))
              ),
              this.rectSelection.set.add(
                this.nested
                  .circle(this.options.radius)
                  .center(d.width / 2, 0)
                  .attr("class", this.options.classPoints + "_t")
                  .mousedown(b("t"))
              ),
              this.rectSelection.set.add(
                this.nested
                  .circle(this.options.radius)
                  .center(d.width, d.height / 2)
                  .attr("class", this.options.classPoints + "_r")
                  .mousedown(b("r"))
              ),
              this.rectSelection.set.add(
                this.nested
                  .circle(this.options.radius)
                  .center(d.width / 2, d.height)
                  .attr("class", this.options.classPoints + "_b")
                  .mousedown(b("b"))
              ),
              this.rectSelection.set.add(
                this.nested
                  .circle(this.options.radius)
                  .center(0, d.height / 2)
                  .attr("class", this.options.classPoints + "_l")
                  .mousedown(b("l"))
              ),
              this.rectSelection.set.each(function () {
                this.addClass(c.options.classPoints);
              })),
            this.options.rotationPoint &&
              !this.rectSelection.set.get(9) &&
              this.rectSelection.set.add(
                this.nested
                  .circle(this.options.radius)
                  .center(d.width / 2, 20)
                  .attr("class", this.options.classPoints + "_rot")
                  .mousedown(function (a) {
                    (a = a || window.event),
                      a.preventDefault
                        ? a.preventDefault()
                        : (a.returnValue = !1),
                      c.el.fire("rot", { x: a.pageX, y: a.pageY, event: a });
                  })
              );
        }),
        (b.prototype.handler = function () {
          var a = this.el.bbox();
          this.nested
            .size(a.width || 1, a.height || 1)
            .transform(this.el.ctm())
            .move(a.x, a.y),
            this.rectSelection.isSelected && this.updateRectSelection(),
            this.pointSelection.isSelected && this.updatePointSelection();
        }),
        (b.prototype.observe = function () {
          var a = this;
          if (MutationObserver)
            if (this.rectSelection.isSelected || this.pointSelection.isSelected)
              (this.observerInst =
                this.observerInst ||
                new MutationObserver(function () {
                  a.handler();
                })),
                this.observerInst.observe(this.el.node, { attributes: !0 });
            else
              try {
                this.observerInst.disconnect(), delete this.observerInst;
              } catch (b) {}
          else
            this.el.off("DOMAttrModified.select"),
              (this.rectSelection.isSelected ||
                this.pointSelection.isSelected) &&
                this.el.on("DOMAttrModified.select", function () {
                  a.handler();
                });
        }),
        (b.prototype.cleanup = function () {
          !this.rectSelection.isSelected &&
            this.rectSelection.set &&
            (this.rectSelection.set.each(function () {
              this.remove();
            }),
            this.rectSelection.set.clear(),
            delete this.rectSelection.set),
            !this.pointSelection.isSelected &&
              this.pointSelection.set &&
              (this.pointSelection.set.each(function () {
                this.remove();
              }),
              this.pointSelection.set.clear(),
              delete this.pointSelection.set),
            this.pointSelection.isSelected ||
              this.rectSelection.isSelected ||
              (this.nested.remove(), delete this.nested);
        }),
        SVG.extend(SVG.Element, {
          select: function (c, d) {
            "object" == typeof c && ((d = c), (c = !0));
            var e = this.remember("_selectHandler") || new b(this);
            return e.init(c === a ? !0 : c, d || {}), this;
          },
        }),
        (SVG.Element.prototype.select.defaults = {
          points: !0,
          classRect: "svg_select_boundingRect",
          classPoints: "svg_select_points",
          radius: 7,
          rotationPoint: !0,
          deepSelect: !1,
        });
    }).call(this);
    (function () {
      SVG.extend(SVG.Element, {
        /**
         * draggy
         * Makes an element draggable.
         *
         * @name draggy
         * @function
         * @param {Object|Function} constraint An object containing the
         * constraint values or a function which gets the `x` and `y` values
         * and returns a boolean or an object containing the `x` and `y`
         * boolean values.`false` skips moving while `true` allows it.
         * @return {SVG} The SVG element.
         */
        draggy: function (constraint) {
          var start,
            drag,
            end,
            element = this;
          // Remove draggable if already present
          if (typeof this.fixed === "function") {
            this.fixed();
          }

          // Ensure constraint object
          constraint = constraint || {};

          // Start dragging
          start = function (event) {
            var parent = null;
            if (typeof this.parent === "function") {
              parent = this.parent(SVG.Nested) || this.parent(SVG.Doc);
            } else {
              this.parent._parent(SVG.Nested) || this._parent(SVG.Doc);
            }
            event = event || window.event;

            // Invoke any callbacks
            if (element.beforedrag) {
              element.beforedrag(event);
            }

            // Get element bounding box
            var box = element.bbox();

            if (element instanceof SVG.G) {
              box.x = element.x();
              box.y = element.y();
            } else if (element instanceof SVG.Nested) {
              box = {
                x: element.x(),
                y: element.y(),
                width: element.width(),
                height: element.height(),
              };
            }

            // Store event
            element.startEvent = event;

            // Store start position
            element.startPosition = {
              x: box.x,
              y: box.y,
              width: box.width,
              height: box.height,
              zoom: parent.viewbox().zoom,
              rotation: (element.transform("rotation") * Math.PI) / 180,
            };

            // Add while and end events to window
            SVG.on(window, "mousemove", drag);
            SVG.on(window, "touchmove", drag);

            SVG.on(window, "mouseup", end);
            SVG.on(window, "touchend", end);

            // Invoke any callbacks
            element.node.dispatchEvent(
              new CustomEvent("dragstart", {
                detail: {
                  event: event,
                  delta: {
                    x: 0,
                    y: 0,
                  },
                },
              })
            );

            // Prevent selection dragging
            if (event.preventDefault) {
              event.preventDefault();
            } else {
              event.returnValue = false;
            }
          };

          function elmZoom(elm) {
            if (!elm || typeof elm.transform !== "function") {
              return { x: 1, y: 1 };
            }
            var p = elm.parent;
            var t = elm.transform();
            pz = {};
            var pz = elmZoom(p);
            return {
              x: t.scaleX * pz.x,
              y: t.scaleY * pz.y,
            };
          }

          // While dragging
          drag = function (event) {
            event = event || window.event;

            if (element.startEvent) {
              // Calculate move position
              var x,
                y,
                rotation = element.startPosition.rotation,
                width = element.startPosition.width,
                height = element.startPosition.height,
                delta = {
                  x: event.pageX - element.startEvent.pageX,
                  y: event.pageY - element.startEvent.pageY,
                };
              if (/^touchstart|touchmove$/.test(event.type)) {
                delta.x =
                  event.touches[0].pageX - element.startEvent.touches[0].pageX;
                delta.y =
                  event.touches[0].pageY - element.startEvent.touches[0].pageY;
              } else if (/^click|mousedown|mousemove$/.test(event.type)) {
                delta.x = event.pageX - element.startEvent.pageX;
                delta.y = event.pageY - element.startEvent.pageY;
              }

              delta.scale = elmZoom(element);

              x =
                element.startPosition.x +
                (delta.x * Math.cos(rotation) + delta.y * Math.sin(rotation)) /
                  Math.pow(delta.scale.x, 2);
              y =
                element.startPosition.y +
                (delta.y * Math.cos(rotation) + delta.x * Math.sin(-rotation)) /
                  Math.pow(delta.scale.y, 2);

              // Move the element to its new position, if possible by constraint
              if (typeof constraint === "function") {
                var coord = constraint(x, y);
                if (typeof coord === "object") {
                  if (typeof coord.x !== "boolean" || coord.x) {
                    x = typeof coord.x === "number" ? coord.x : x;
                    element.x(x);
                  } else {
                    x = element.x();
                  }

                  if (typeof coord.y !== "boolean" || coord.y) {
                    y = typeof coord.y === "number" ? coord.y : y;
                    element.y(y);
                  } else {
                    y = element.y();
                  }
                } else if (typeof coord === "boolean" && coord) {
                  element.move(x, y);
                } else {
                  x = element.x();
                  y = element.y();
                }
              } else if (typeof constraint === "object") {
                // Keep element within constrained box
                if (constraint.minX !== null && x < constraint.minX) {
                  x = constraint.minX;
                } else if (
                  constraint.maxX !== null &&
                  x > constraint.maxX - width
                ) {
                  x = constraint.maxX - width;
                }

                if (constraint.minY !== null && y < constraint.minY) {
                  y = constraint.minY;
                } else if (
                  constraint.maxY !== null &&
                  y > constraint.maxY - height
                ) {
                  y = constraint.maxY - height;
                }

                element.move(x, y);
              }

              // Calculate the total movement
              delta.movedX = x - element.startPosition.x;
              delta.movedY = y - element.startPosition.y;

              // Invoke any callbacks
              element.node.dispatchEvent(
                new CustomEvent("dragmove", {
                  detail: {
                    delta: delta,
                    event: event,
                  },
                })
              );
            }
          };

          // When dragging ends
          end = function (event) {
            event = event || window.event;

            // Calculate move position
            var delta = {
              x: event.pageX - element.startEvent.pageX,
              y: event.pageY - element.startEvent.pageY,
              zoom: element.startPosition.zoom,
            };

            // Reset store
            element.startEvent = null;
            element.startPosition = null;

            // Remove while and end events to window
            SVG.off(window, "mousemove", drag);
            SVG.off(window, "touchmove", drag);
            SVG.off(window, "mouseup", end);
            SVG.off(window, "touchend", end);

            // Invoke any callbacks
            element.node.dispatchEvent(
              new CustomEvent("dragend", {
                detail: {
                  delta: {
                    x: 0,
                    y: 0,
                  },
                  event: event,
                },
              })
            );
          };

          // Bind mousedown event
          element.on("mousedown", start);
          element.on("touchstart", start);

          // Disable draggable
          element.fixed = function () {
            element.off("mousedown", start);
            element.off("touchstart", start);

            SVG.off(window, "mousemove", drag);
            SVG.off(window, "touchmove", drag);
            SVG.off(window, "mouseup", end);
            SVG.off(window, "touchend", end);

            start = drag = end = null;

            return element;
          };

          return this;
        },
      });
    }).call(this);

    (function (f) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.CSSRotate = f();
      }
    })(function () {
      var define, module, exports;
      return (function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof require == "function" && require;
              if (!u && a) return a(o, !0);
              if (i) return i(o, !0);
              var f = new Error("Cannot find module '" + o + "'");
              throw ((f.code = "MODULE_NOT_FOUND"), f);
            }
            var l = (n[o] = { exports: {} });
            t[o][0].call(
              l.exports,
              function (e) {
                var n = t[o][1][e];
                return s(n ? n : e);
              },
              l,
              l.exports,
              e,
              t,
              n,
              r
            );
          }
          return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
      })(
        {
          1: [
            function (require, module, exports) {
              var CSSTransform = require("cross-transform");
              function CSSRotate(elm, angle) {
                return CSSTransform(elm, "rotate(" + angle + "deg)");
              }
              module.exports = CSSRotate;
            },
            { "cross-transform": 2 },
          ],
          2: [
            function (require, module, exports) {
              var Crossy = require("crossy");
              function CSSCrossTransform(elm, value) {
                return Crossy(elm, "transform", value);
              }
              module.exports = CSSCrossTransform;
            },
            { crossy: 4 },
          ],
          3: [
            function (require, module, exports) {
              var UFirst = require("ucfirst");
              function CrossStyle(input) {
                var uInput = UFirst(input);
                return [
                  "webkit" + uInput,
                  "moz" + uInput,
                  "ms" + uInput,
                  "o" + uInput,
                  input,
                ];
              }
              module.exports = CrossStyle;
            },
            { ucfirst: 6 },
          ],
          4: [
            function (require, module, exports) {
              var ElmSelect = require("elm-select"),
                CrossStyle = require("cross-style");
              function Crossy(elm, prop, value) {
                if (typeof elm === "string") {
                  return ElmSelect(elm, Crossy, [prop, value]);
                }
                var i = 0,
                  styles = CrossStyle(prop);
                for (; i < styles.length; ++i) {
                  elm.style[styles[i]] = value;
                }
                return elm;
              }
              module.exports = Crossy;
            },
            { "cross-style": 3, "elm-select": 5 },
          ],
          5: [
            function (require, module, exports) {
              function ElmSelect(elm, fn, args) {
                var i = 0,
                  _args = null;
                if (typeof elm === "string") {
                  elm = document.querySelectorAll(elm);
                }
                if (elm.constructor !== NodeList) {
                  elm = [elm];
                }
                if (typeof fn === "function") {
                  if (!Array.isArray(args)) {
                    args = [args];
                  }
                  for (; i < elm.length; ++i) {
                    _args = [elm[i]].concat(args);
                    fn.apply(this, _args);
                  }
                }
                return elm;
              }
              module.exports = ElmSelect;
            },
            {},
          ],
          6: [
            function (require, module, exports) {
              "use strict";
              module.exports = function (s) {
                return s.substr(0, 1).toUpperCase() + s.substring(1);
              };
            },
            {},
          ],
        },
        {},
        [1]
      )(1);
    });
    (function (f) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.Crossy = f();
      }
    })(function () {
      var define, module, exports;
      return (function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof require == "function" && require;
              if (!u && a) return a(o, !0);
              if (i) return i(o, !0);
              var f = new Error("Cannot find module '" + o + "'");
              throw ((f.code = "MODULE_NOT_FOUND"), f);
            }
            var l = (n[o] = { exports: {} });
            t[o][0].call(
              l.exports,
              function (e) {
                var n = t[o][1][e];
                return s(n ? n : e);
              },
              l,
              l.exports,
              e,
              t,
              n,
              r
            );
          }
          return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
      })(
        {
          1: [
            function (require, module, exports) {
              var UFirst = require("ucfirst");
              function CrossStyle(input) {
                var uInput = UFirst(input);
                return [
                  "webkit" + uInput,
                  "moz" + uInput,
                  "ms" + uInput,
                  "o" + uInput,
                  input,
                ];
              }
              module.exports = CrossStyle;
            },
            { ucfirst: 4 },
          ],
          2: [
            function (require, module, exports) {
              var ElmSelect = require("elm-select"),
                CrossStyle = require("cross-style");
              function Crossy(elm, prop, value) {
                if (typeof elm === "string") {
                  return ElmSelect(elm, Crossy, [prop, value]);
                }
                var i = 0,
                  styles = CrossStyle(prop);
                for (; i < styles.length; ++i) {
                  elm.style[styles[i]] = value;
                }
                return elm;
              }
              module.exports = Crossy;
            },
            { "cross-style": 1, "elm-select": 3 },
          ],
          3: [
            function (require, module, exports) {
              function ElmSelect(elm, fn, args) {
                var i = 0,
                  _args = null;
                if (typeof elm === "string") {
                  elm = document.querySelectorAll(elm);
                }
                if (elm.constructor !== NodeList) {
                  elm = [elm];
                }
                if (typeof fn === "function") {
                  if (!Array.isArray(args)) {
                    args = [args];
                  }
                  for (; i < elm.length; ++i) {
                    _args = [elm[i]].concat(args);
                    fn.apply(this, _args);
                  }
                }
                return elm;
              }
              module.exports = ElmSelect;
            },
            {},
          ],
          4: [
            function (require, module, exports) {
              "use strict";
              module.exports = function (s) {
                return s.substr(0, 1).toUpperCase() + s.substring(1);
              };
            },
            {},
          ],
        },
        {},
        [2]
      )(2);
    });

    window.showTutorial = function () {
      swal({
        title: "Tutorial",
        html: true,
        confirmButtonText: "Mengerti!",
        text:
          "<ul>" +
    "    <li><strong>Klik kiri</strong>: putar ke kiri</li>" +
    "    <li><strong>Klik kanan</strong>: putar ke kanan</li>" +
    "    <li><strong>CTRL + klik kiri</strong>: balik bentuk</li>" +
    "    <li><strong>Tahan klik kiri + gerakkan</strong>: geser</li>" +
    "</ul>" +
    "<div class='made-with-heart'>",
      });
    };
    window.addEventListener("load", function () {
      var t = new SVG(document.querySelector(".graph")).size("100%", "100%"),
        winSize = {
          w: window.innerWidth,
          h: window.innerHeight,
        },
        elements = t.group().id("elements"),
        shapes = [
          elements.group(),
          elements.group(),
          elements.group(),
          elements.group(),
          elements.group(),
          elements.group(),
          elements.group(),
        ],
        size = winSize.w / 3.5,
        half = size / 2,
        quart = half / 2,
        q3 = quart * 3,
        leftTopCorner = {
          x: winSize.w / 2 - size / 2,
          y: 30,
        };
      // 1. Big Triangle
      shapes[0]
        .polygon("0,0 " + half + "," + half + " " + size + ",0")
        .fill("#e74c3c");

      // 2. Big Triangle
      shapes[1]
        .polygon("0,0 " + half + "," + half + " 0," + size)
        .fill("#e67e22");

      // 3. Medium Triangle
      shapes[2]
        .polygon(
          size + "," + size + " " + half + "," + size + " " + size + "," + half
        )
        .fill("#f1c40f");

      // 4. Small Triangle
      shapes[3]
        .polygon(size + ",0 " + q3 + "," + quart + " " + size + "," + half)
        .fill("#2ecc71");

      // 5. Small Triangle
      shapes[4]
        .polygon(
          half + "," + half + " " + quart + "," + q3 + " " + q3 + "," + q3
        )
        .fill("#3498db");

      // 6. Square
      shapes[5]
        .polygon(
          half +
            "," +
            half +
            " " +
            q3 +
            "," +
            q3 +
            " " +
            size +
            "," +
            half +
            " " +
            q3 +
            "," +
            quart
        )
        .fill("#9b59b6");

      // 7. Parallelogram
      shapes[6]
        .polygon(
          "0," +
            size +
            " " +
            quart +
            "," +
            q3 +
            " " +
            q3 +
            "," +
            q3 +
            " " +
            half +
            "," +
            size
        )
        .fill("#34495e");

      Crossy("polygon", "transformOrigin", "center");
      Crossy("polygon", "transformBox", "fill-box");
      Crossy("polygon", "transition", "all 500 ease");

      shapes.forEach(function (c) {
        var moved = false;
        var angle = 0;
        var cPol = c.children()[0];
        c.translate(leftTopCorner.x, leftTopCorner.y);
        c.draggy();
        c.on("dragmove", function () {
          moved = true;
        });

        cPol.on("mousedown", function () {
          moved = false;
        });

        cPol.on("contextmenu", function (e) {
          e.preventDefault();
        });

        cPol.on("mouseup", function (e) {
          if (!moved) {
            var t = this.node.style.transform;

            if (e.ctrlKey) {
              this.node._scale = (this.node._scale || 1) === 1 ? -1 : 1;
            } else {
              angle += (e.button === 2 ? 1 : -1) * 45;
            }

            Crossy(
              this.node,
              "transform",
              "rotate(" + angle + "deg) scaleX(" + (this.node._scale || 1) + ")"
            );
          }
          moved = false;
          e.preventDefault();
        });
      });
    });
  </script>
</html>
